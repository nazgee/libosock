/*
 * socket.cpp
 *
 *  Created on: Mar 3, 2011
 *      Author: nazgee
 */

#include "Socket.h"
#include "../defines.h"
#include "../Exception/Exception.h"
#include "../Security/Security.h"

#include <assert.h>
#include <arpa/inet.h>

///////////////////////////////////////////////////////////////////////////////
/// Socket
//-----------------------------------------------------------------------------
//--- Constructors & Destructors
<<<<<<< HEAD:src/socket.cpp
Socket::Socket(void):
	itsSSL(NULL),
=======
Socket::Socket(BIO * bio) :
	itsBIO(bio)
{
	DBG_CONSTRUCTOR;
}

Socket::Socket(void):
>>>>>>> 4cbf48f... WIP:src/Socket/Socket.cpp
	itsSD(-1)
{
	DBG_CONSTRUCTOR;
}

<<<<<<< HEAD:src/socket.cpp
Socket::Socket(int sd, SSL *ssl):
	itsSSL(ssl),
	itsSD(sd)
{
	//TODO: throw badargs exception, instead of assertion failure
	assert(itsSSL != NULL); //secure socket without security is stupid

	DBG << this << std::endl;
=======
Socket::Socket(int sd):
	itsSD(sd)
{
	DBG_CONSTRUCTOR;
>>>>>>> 4cbf48f... WIP:src/Socket/Socket.cpp
}

Socket::Socket(ENetwork Network, EProtocol Protocol)
{
	itsSD = socket(Network, Protocol, 0);
	if ( itsSD < 0 )
		throw NetException("Could not create socket");

	DBG_CONSTRUCTOR;
}

Socket::Socket(Socket& sock)
{
	int err;
	socklen_t size=sizeof(err);

	if ( getsockopt(itsSD, SOL_SOCKET, SO_ERROR, &err, &size) != 0 )
		throw NetException("Socket error");
	if ( (itsSD = dup(sock.itsSD)) < 0 )
		throw FileException("Can't copy socket");

	DBG_CONSTRUCTOR;
}

Socket::~Socket(void)
{
<<<<<<< HEAD:src/socket.cpp
	DBG << this << std::endl;

	if ((itsSD != -1) && ( close(itsSD) != 0 ))
		throw FileException("Can't close socket");

	if (itsSSL)
		SSL_free(itsSSL);
=======
	DBG_DESTRUCTOR;
>>>>>>> 4cbf48f... WIP:src/Socket/Socket.cpp
}

//-----------------------------------------------------------------------------
//--- Specific Implementation
void Socket::Bind(Address& Addr)
{
	if ( bind(itsSD, Addr.GetAddress(), Addr.GetSize()) != 0 )
		throw NetConnectException("Could not bind socket");
}

int  Socket::Send(Message& Msg, int Options) const
{
<<<<<<< HEAD:src/socket.cpp
	int bytes;
	char *buf = Msg.Wrap(bytes);

	if (itsSSL) {
		bytes = SSL_write(itsSSL, buf, bytes);
	} else {
		bytes = send(itsSD, buf, bytes, Options);
	}

	delete[] buf;
	if ( bytes < 0 )
		throw NetIOException("Could not send message");
	return bytes;
}

int  Socket::Send(HostAddress& Addr, Message& Msg, int Options) const
{
	int bytes;
	char *buf = Msg.Wrap(bytes);
	bytes = sendto(itsSD, buf, bytes, Options, Addr.GetAddress(), Addr.GetSize());
	delete[] buf;
	if ( bytes < 0 )
		throw NetIOException("Could not send directed message");
=======
	int bytes = 0;
	char *buf = Msg.Unwrap(bytes);

	int i, off = 0;
	for (;;) {
		DBG << "sending " << bytes << "B" << std::endl;
		i = BIO_write(itsBIO, &buf[off], bytes);
		if (i <= 0) {
			if (BIO_should_retry(itsBIO)) {
				DBG << "sleeping before retrying write" << std::endl;
				sleep(1);
				continue;
			}
			throw_SSL();
		}
		off += i;
		bytes -= i;
		if (bytes <= 0)
			break;
	}

>>>>>>> 4cbf48f... WIP:src/Socket/Socket.cpp
	return bytes;
}

int  Socket::Receive(Message& Msg, int Options) const
{
	DBG << "waiting for message" << std::endl;
	bool done;
	int bytes, cnt=0;
<<<<<<< HEAD:src/socket.cpp
	char *buf = new char[BufferSize];
	do
	{
		if (itsSSL) {
			bytes = SSL_read(itsSSL, buf, BufferSize);
		} else {
			bytes = recv(itsSD, buf, BufferSize, Options);
		}

		if ( bytes < 0 )
		{
			delete[] buf;
			throw NetIOException("Could could get message");
=======
	static const int bufsize = 8;
	char *buf = new char[bufsize];

	do {
		bytes = BIO_read(itsBIO, buf, bufsize);
		if (bytes == 0)
			throw_DBG_SSL("connection with client broken");

		if (bytes < 0) {
			if (BIO_should_retry(itsBIO)) {
				DBG << "sleeping before retrying read" << std::endl;
				sleep(1);
				continue;
			}
			throw_SSL();
>>>>>>> 4cbf48f... WIP:src/Socket/Socket.cpp
		}
		cnt++;
		DBG << "received " << bytes << "B in chunk=" << cnt<< std::endl;
		done = Msg.Wrap(buf, bytes, cnt);
	} while ( !done );
	delete[] buf;

<<<<<<< HEAD:src/socket.cpp
int  Socket::Receive(HostAddress& Addr, Message& Msg, int Options) const
{	const int BufferSize = 65536;
	socklen_t len = Addr.GetSize();
	bool done;
	int bytes, cnt=0;
	char *buf = new char[BufferSize];
	do
	{
		bytes = recvfrom(itsSD, buf, BufferSize, Options, Addr.GetAddress(), &len);
		if ( bytes < 0 )
		{
			delete[] buf;
			throw NetIOException("Could could get message");
		}
		cnt++;
		done = Msg.Unwrap(buf, bytes, cnt);
	}
	while ( !done );
	delete[] buf;
=======
>>>>>>> 4cbf48f... WIP:src/Socket/Socket.cpp
	return bytes;
}

//-----------------------------------------------------------------------------
//--- Class configuration (CRUD)
void Socket::PermitRoute(bool Setting)
{
	int val = (Setting == 0);
	if ( setsockopt(itsSD, SOL_SOCKET, SO_DONTROUTE, &val, sizeof(val)) != 0 )
		throw NetConfigException("Socket Option: set DONTROUTE");
}

void Socket::KeepAlive(bool Setting)
{
	int val = (Setting != 0);
	if ( setsockopt(itsSD, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) != 0 )
		throw NetConfigException("Socket Option: set KEEPALIVE");
}

void Socket::ShareAddress(bool Setting)
{
	int val = (Setting != 0);
	if ( setsockopt(itsSD, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) != 0 )
		throw NetConfigException("Socket Option: set REUSEADDR");
}

int  Socket::GetReceiveSize(void)
{
	int val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_RCVBUF, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get RCVBUF");
	return val;
}

void Socket::SetReceiveSize(int Bytes)
{
	if ( setsockopt(itsSD, SOL_SOCKET, SO_RCVBUF, &Bytes, sizeof(Bytes)) != 0 )
		throw NetConfigException("Socket Option: set RCVBUF");
}

int  Socket::GetSendSize(void)
{
	int val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_SNDBUF, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get SNDBUF");
	return val;
}

void Socket::SetSendSize(int Bytes)
{
	if ( setsockopt(itsSD, SOL_SOCKET, SO_SNDBUF, &Bytes, sizeof(Bytes)) != 0 )
		throw NetConfigException("Socket Option: set SNDBUF");
}

int  Socket::GetMinReceive(void)
{
	int val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_RCVLOWAT, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get RCVLOWAT");
	return val;
}

void Socket::SetMinReceive(int Bytes) //---Not yet implemented in Linux
{
	if ( setsockopt(itsSD, SOL_SOCKET, SO_RCVLOWAT, &Bytes, sizeof(Bytes)) != 0 )
		throw NetConfigException("Socket Option: set RCVLOWAT");
}

int  Socket::GetMinSend(void)
{
	int val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_SNDLOWAT, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get SNDLOWAT");
	return val;
}

void Socket::SetMinSend(int Bytes) //---Not yet implemented in Linux
{
	if ( setsockopt(itsSD, SOL_SOCKET, SO_SNDLOWAT, &Bytes, sizeof(Bytes)) != 0 )
		throw NetConfigException("Socket Option: set SNDLOWAT");
}

struct timeval Socket::GetReceiveTimeout(void)
{
	struct timeval val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_RCVTIMEO, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get RCVTIMEO");
	return val;
}

void Socket::SetReceiveTimeout(struct timeval& val) //---Not yet implemented in Linux
{
	if ( setsockopt(itsSD, SOL_SOCKET, SO_RCVTIMEO, &val, sizeof(val)) != 0 )
		throw NetConfigException("Socket Option: set RCVTIMEO");
}

struct timeval Socket::GetSendTimeout(void)
{
	struct timeval val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_SNDTIMEO, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get SNDTIMEO");
	return val;
}

void Socket::SetSendTimeout(struct timeval& val) //---Not yet implemented in Linux
{
	if ( setsockopt(itsSD, SOL_SOCKET, SO_SNDTIMEO, &val, sizeof(val)) != 0 )
		throw NetConfigException("Socket Option: set SNDTIMEO");
}

ENetwork Socket::GetType(void)
{
	int val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_TYPE, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get TYPE");
	return (ENetwork)val;
}

int  Socket::GetTTL(void)
{
	int val;
	socklen_t size=sizeof(val);
	if ( GetType() == eIPv4 )
	{
		if ( getsockopt(itsSD, SOL_IP, IP_TTL, &val, &size) != 0 )
			throw NetConfigException("IP Option: get TTL");
	}
	else if ( GetType() == eIPv6 )
	{
		if ( getsockopt(itsSD, SOL_IPV6, IPV6_UNICAST_HOPS, &val, &size) != 0 )
			throw NetConfigException("IP Option: get MULTICAST_TTL");
	}
	return val;
}

void Socket::SetTTL(int Hops)
{
	if ( GetType() == eIPv4 )
	{
		if ( setsockopt(itsSD, SOL_IP, IP_TTL, &Hops, sizeof(Hops)) != 0 )
			throw NetConfigException("IP Option: set TTL");
	}
	else if ( GetType() == eIPv6 )
	{
		if ( setsockopt(itsSD, SOL_IPV6, IPV6_UNICAST_HOPS, &Hops, sizeof(Hops)) != 0 )
			throw NetConfigException("IP Option: set MULTICAST_TTL");
	}
}

int  Socket::GetError(void)
{
	int val;
	socklen_t size=sizeof(val);
	if ( getsockopt(itsSD, SOL_SOCKET, SO_ERROR, &val, &size) != 0 )
		throw NetConfigException("Socket Option: get ERROR");
	return val;
}

std::ostream& operator <<(std::ostream &os,const Socket *obj)
{
<<<<<<< HEAD:src/socket.cpp
	if (obj->itsSSL){
		os << "secure; SD=" << obj->itsSD << " itsSSL=" << obj->itsSSL;
	} else {
		os << "casual; SD=" << obj->itsSD << " itsSSL=" << obj->itsSSL;
	}

=======
	os << (void*)obj << " (TO BE SERIALIZED)";
>>>>>>> 4cbf48f... WIP:src/Socket/Socket.cpp
	return os;
}

std::ostream& operator <<(std::ostream &os,const Socket &obj)
{
	return operator<<(os, &obj);
}
